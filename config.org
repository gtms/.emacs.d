#+TITLE: Personal Emacs Configuration
#+AUTHOR: Gil Tomás
#+STARTUP: overview

* What needs to be done
  The plan is to reorganise the structure of this file along that of the Emacs
  Manual and that of Mickey Petersen's Mastering Emacs.  Another great source of
  ideas to guide the reorganisation of this file is the [[https://github.com/emacs-tw/awesome-emacs][Awesome Emacs]] site on
  Github.

** TODO Also to do is the optimisation of Emacs' startup time

** TODO And the uniformisation of the global keybindings and major modes

* Intro
This file is my personal literate ~Emacs~ configuration, written in Org Mode.
Snippets in this file that:

- are not marked as :tangle no
- are marked as =emacs lisp= source code
- do not have the org-mode todo label CANCELLED

are tangled into the config.el file living in ~/.emacs.d, in an efficient and
elligible manner.

* Load =custom.el=
Saving customizations works by writing code to a file, usually the
initialization file (=init.el=).  Subsequent emacs sessions automatically read
this file at startup, which sets up the customizations again.

To avoid cluttering the =init.el= file, customizations can be saved into a
=custom.el= file, which can even be specified for different Emacs versions (see
section 49.1.4 of the Emacs manual).  Note that Emacs sessions invoked with the
=`-q'= or =`--no-init-file'= options will not save customizations to the
initialization file.

#+BEGIN_SRC emacs-lisp
  (setq custom-file (expand-file-name "custom.el" user-emacs-directory))
  (when (file-exists-p "custom.el")
    (load custom-file))
#+END_SRC

* Core
These were taken from [[https://github.com/bbatsov/prelude%5D][Prelude Emacs]], Bozidar Batsov [[https://github.com/bbatsov/emacs.d][init.el]], my previous
iteration of config.org, as well as various other sources.

#+BEGIN_SRC emacs-lisp
  (setq user-full-name "Gil Tomás"
        user-mail-address "gil.tms@gmail.com")
  ;; Always load newest byte code
  (setq load-prefer-newer t)
  ;; Reduce the frequency of garbage collection by making it happen on
  ;; each 50MB of allocated data (the default is on every 0.76MB)
  (setq gc-cons-threshold 50000000)
  ;; Warn when opening files bigger than 100MB
  (setq large-file-warning-threshold 100000000)
  ;; Create the savefile dir if it doesn't exist
  (defconst savefile-dir (expand-file-name "savefile" user-emacs-directory))
  (unless (file-exists-p savefile-dir)
  (make-directory savefile-dir))
  ;; Enable y/n answers
  (fset 'yes-or-no-p 'y-or-n-p)
  ;; configures emacs so that word moving commands will move cursor into
  ;; between CamelCaseWords
  (global-subword-mode 1)
  ;; sets set-mark-command-repeat-pop to TRUE
  ;; non-nil means repeating C-SPC after popping mark pops it again
  (setq set-mark-command-repeat-pop t)
  ;; The right margin is determined by the variable fill-column.  The default
  ;; value for fill-column is 70; here we set it to 80.
  ;; 21Sep2016
  (setq-default fill-column 80)
  ;; 27Aug2017
  ;; From Mickey Petersen's Mastering Emacs
  ;; https://www.masteringemacs.org/article/working-coding-systems-unicode-emacs
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-terminal-coding-system 'utf-8)
  (set-keyboard-coding-system 'utf-8)
  ;; 26Jun2018
  ;; Activate display-line-numbers-mode on prog-mode
  (progn
    (add-hook 'prog-mode-hook (lambda () (display-line-numbers-mode 1)))
    (add-hook 'text-mode-hook (lambda () (display-line-numbers-mode 1))))
  (setq display-line-numbers-type (quote visual))
  ;; 04Jan2019
  ;; Enable winner-mode
  ;; https://www.emacswiki.org/emacs/WinnerMode
  (when (fboundp 'winner-mode)
    (winner-mode 1))
  ;; 17Jan2019
  ;; Window switching backwards
  (global-set-key (kbd "C-x O") (lambda ()
                                  (interactive)
                                  (other-window -1)))
  ;; Mickey Petersen
  ;; Effective Editing Movement
  ;; https://www.masteringemacs.org/article/effective-editing-movement
  ;; 04Feb2019
  (setq next-line-add-newlines t)
#+END_SRC

[2019-01-16 Wed]
From bbatov init.el file:

#+BEGIN_SRC emacs-lisp
;; Emacs modes typically provide a standard means to change the
;; indentation width -- eg. c-basic-offset: use that to adjust your
;; personal indentation width, while maintaining the style (and
;; meaning) of any files you load.
(setq-default indent-tabs-mode nil)   ;; don't use tabs to indent
(setq-default tab-width 8)            ;; but maintain correct appearance

;; Newline at end of file
(setq require-final-newline t)

;; delete the selection with a keypress
(delete-selection-mode t)

;; store all backup and autosave files in the tmp dir
(setq backup-directory-alist
      `((".*" . ,temporary-file-directory)))
(setq auto-save-file-name-transforms
      `((".*" ,temporary-file-directory t)))

;; revert buffers automatically when underlying files are changed externally
(global-auto-revert-mode t)

(prefer-coding-system 'utf-8)
(set-default-coding-systems 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)

;; hippie expand is dabbrev expand on steroids
(setq hippie-expand-try-functions-list '(try-expand-dabbrev
                                         try-expand-dabbrev-all-buffers
                                         try-expand-dabbrev-from-kill
                                         try-complete-file-name-partially
                                         try-complete-file-name
                                         try-expand-all-abbrevs
                                         try-expand-list
                                         try-expand-line
                                         try-complete-lisp-symbol-partially
                                         try-complete-lisp-symbol))

;; use hippie-expand instead of dabbrev
(global-set-key (kbd "M-/") #'hippie-expand)

;; replace buffer-menu with ibuffer
(global-set-key (kbd "C-x C-b") #'ibuffer)

;; align code in a pretty way
(global-set-key (kbd "C-x \\") #'align-regexp)

;; smart tab behavior - indent or complete
(setq tab-always-indent 'complete)
#+END_SRC

* Package Management
** package archives
   First, we add melpa to our list of repositories.  Packages are installed in
   the elpa folder under =user-emacs-directory=.  We then update package
   metadata if the local cache is missing.

#+BEGIN_SRC emacs-lisp
(require 'package)
(setq package-archives '(("gnu"   . "https://elpa.gnu.org/packages/")
                         ("melpa" . "https://melpa.org/packages/")
                         ("org"   . "https://orgmode.org/elpa/")))
(setq package-user-dir (expand-file-name "elpa" user-emacs-directory))
(package-initialize)
(unless package-archive-contents
  (package-refresh-contents))
#+END_SRC

** use-package
Package management is done via =use-package=.

#+BEGIN_SRC emacs-lisp
(unless (package-installed-p 'use-package)
  (package-install 'use-package))
(require 'use-package)
(setq use-package-verbose t)
#+END_SRC

* User Interface
** miscelaneous
   Most of these settings are taken from prelude-ui.el.

   #+BEGIN_SRC emacs-lisp
   ;; Remove toolbar, menubar and scrollbar
   (when (fboundp 'tool-bar-mode)
     (tool-bar-mode -1))
   (menu-bar-mode -1)
   (toggle-scroll-bar -1)
   ;; Remove blinking cursor
   (blink-cursor-mode -1)
   ;; Disable the ring bell
   (setq ring-bell-function 'ignore)
   ;; Disable startup screen
   (setq inhibit-startup-screen t)
   ;; Better scrolling
   (setq scroll-margin 0
         scroll-conservatively 100000
         scroll-preserve-screen-position 1)
   ;; More useful frame title, that show either a file or a
   ;; buffer name (if the buffer isn't visiting a file)
   (setq frame-title-format '((:eval (if (buffer-file-name)
                                         (abbreviate-file-name (buffer-file-name))
                                       "%b"))))
   #+END_SRC

** font
   The default font is Source Code Pro, where available.

   #+BEGIN_SRC emacs-lisp
     (set-frame-font "Source Code Pro")
   #+END_SRC

** theme
   Default theme is doom-nord-light.  Zenburn is also installed.  Themes can be
   changed via =counsel-load-theme=.

   #+BEGIN_SRC emacs-lisp
   (use-package zenburn-theme
     :ensure t
     :defer t)

   (use-package doom-themes
     :ensure t
     :config
     (setq doom-themes-enable-bold t
           doom-themes-enable-italic t)
     (doom-themes-org-config)
     (if (display-graphic-p)
         (load-theme 'doom-nord-light t)))
   #+END_SRC

** mode line
*** what to show
    From [[https://www.emacswiki.org/emacs/ModeLineConfiguration][EmacsWiki]].
    Taken on [2017-07-05 Wed]

    #+BEGIN_SRC emacs-lisp
      ;; (setq line-number-mode nil)
      (setq column-number-mode t)
      (setq size-indication-mode nil)
      (setq display-time-day-and-date t)
      (setq display-time-default-load-average nil)
      (display-time)
    #+END_SRC

*** smart-mode-line
#+BEGIN_SRC emacs-lisp
  (use-package smart-mode-line
    :ensure t
    :config
    (setq sml/theme 'respectful)
    (setq sml/name-width 30)
    (setq sml/mode-width 'full)
    (setq sml/no-confirm-load-theme t)
    (setf rm-whitelist " SP")
    (sml/setup))
  #+END_SRC

* The Theory of Movement
** the basics
** window management
** elemental movement
** selections and regions
** searching and indexing

* The Theory of Editing
** killing and yanking text
** transposing text
** filling and commenting
** search and replace
** text manipulation
** keyboard macros
** text expansion
** indenting text and code
** sorting and aligning
** other editing commands
* The Practicals of Emacs
* Org Mode
  Org Mode is kept up-to-date via the orgmode.org archive repository.

  #+BEGIN_SRC emacs-lisp
    (use-package org
      :ensure org-plus-contrib
      :pin org
      :config
      (add-hook 'org-mode-hook 'worf-mode)
      (add-hook 'org-mode-hook 'org-bullets-mode)
      (use-package org-tempo))
  #+END_SRC

** org-bullets
   Show bullets in org-mode as UTF-8 characters.

   #+begin_src emacs-lisp
   (use-package org-bullets
     :ensure t
     :defer t
     :config
     (setq org-bullets-bullet-list '("•")))
   #+end_src

* Built-in Packages
** paren
   =show-paren-mode= allows one to see matching pairs of parentheses and other
   characters.  When point is on the opening character of one of the paired
   characters, the other is highlighted.  When the point is after the closing
   character of one of the paired characters, the other is highlighted.

#+BEGIN_SRC emacs-lisp
  (use-package paren
    :config
    (show-paren-mode 1))
#+END_SRC

** hl-line
   [[https://www.emacswiki.org/emacs/GnuEmacs][GnuEmacs]] version 21 has library `hl-line.el', which provides a local and a
   global minor mode for highlighting the current line.  See [[http://www.emacswiki.org/cgi-bin/info-ref?find=highlight%2520current%2520line][highlight current
   line]].

#+BEGIN_SRC emacs-lisp
  (use-package hl-line
    :config (global-hl-line-mode 1))
#+END_SRC

** abbrev
Emacs has a nice feature to expand abbreviations.  If, for example, you wanted
an abbreviation for ‘Your Name’ to be ‘yn’, just type ‘yn’ and with your point
after the ‘n’ do =C-x a i g= (mnemonic add inverse global) and enter the
expansion, in this case ‘Your Name’.  In the future, whenever you type ‘yn’ your
name will be inserted.  The abbrevs are automatically saved between sessions in
a file =~/.abbrev_defs=.

#+BEGIN_SRC emacs-lisp
(use-package abbrev
  :config
  (setq save-abbrevs 'silently)
  (setq-default abbrev-mode t))
#+END_SRC
** bookmarks
   Taken from section 13.8 of the Emacs Manual, on [2019-02-04 Mon].  Bookmarks
   are somewhat like registers in that they record positions you can jump to.
   Unlike registers, they have long names, and they persist automatically from
   one Emacs session to the next.  The prototypical use of bookmarks is to
   record where you reading in various files.

   #+begin_src emacs-lisp
   (use-package bookmarks
     :defer t
     :config
     (setq bookmark-default-file
           (expand-file-name "bookmarks" savefile-dir)
           bookmark-save-flag 1))
   #+end_src

** dired
[[https://www.emacswiki.org/emacs/DiredMode][DiredMode]] is the mode of a [[https://www.emacswiki.org/emacs?search=%2522Dired%2522][Dired]] buffer.  It shows a directory (folder) listing
that you can use to perform various operations on files and subdirectories in
the directory.  The operations you can perform are numerous, from creating
subdirectories to byte-compiling files, searching files, and of course visiting
(editing) files.

*** dired configuration
#+BEGIN_SRC emacs-lisp
(put 'dired-find-alternate-file 'disabled nil)
(setq dired-dwim-target t)
#+END_SRC

*** dired-x
    The [[https://www.emacswiki.org/emacs/GnuEmacs][GnuEmacs]] library [[https://www.emacswiki.org/emacs?search=%2522Dired+X%2522][Dired X]] ([[https://www.emacswiki.org/emacs?search=%2522dired-x%2522][dired-x]].el) provides extra functionality for
    DiredMode.  It comes with Emacs.

    A manual comes with Emacs documenting these extra features for Dired
    Mode.  Origanally written by [[https://www.emacswiki.org/emacs/SebastianKremer][SebastianKremer]].

    #+BEGIN_SRC emacs-lisp
    ;; enable some really cool extensions like C-x C-j (dired-jump)
(use-package dired-x
  :config
  ;; 15Aug2018
  ;; include hidden files in dired-omit-files variable
  ;; section 3.2 of dired-x manual
  (setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\..+$"))
#+END_SRC

*** dired-rsync
    This package adds a single command dired-rsync which allows the user to copy
    marked files in a dired buffer via rsync.  This is useful, especially for
    large files, because the copy happens in the background and doesn’t lock up
    Emacs.  It is also more efficient than using tramps own encoding methods for
    moving data between systems.

    #+BEGIN_SRC emacs-lisp
    (use-package dired-rsync
      :ensure t
      :config
      (bind-key "Y" 'dired-rsync dired-mode-map))
#+END_SRC

*** dired-filter
The filtering system is designed after ibuffer: every dired buffer has
associated "filter stack" where user can push filters (predicates).  These
filters are by default logically "anded", meaning, only the files satsifying all
the predicates are shown.

#+BEGIN_SRC emacs-lisp
(use-package dired-filter
  :ensure t
  :defer t)
#+END_SRC

*** dired-narrow
    This package provides live filtering of files in dired buffers.  In general,
    after calling the respective narrowing function you type a filter string
    into the minibuffer.  After each change the changes automatically reflect in
    the buffer.  Typing C-g will cancel the narrowing and restore the original
    view, typing RET will exit the live filtering mode and leave the dired
    buffer in the narrowed state. To bring it back to the original view, you can
    call revert-buffer (usually bound to g).

    The following snippet was taken from [[http://pragmaticemacs.com/emacs/dynamically-filter-directory-listing-with-dired-narrow/][here]] on [2017-12-08 Fri].

#+BEGIN_SRC emacs-lisp
(use-package dired-narrow
  :ensure t
  :bind
  (:map dired-mode-map
        ("/" . dired-narrow)))
#+END_SRC

*** find-dired
    [2018-07-03 Tue]
    From Mickey Petersen's [[https://www.masteringemacs.org/article/working-multiple-files-dired][masteringemacs.org]]:

#+BEGIN_QUOTE
The command =find-dired= will use =find= to match the files and =ls= to format
them so dired can understand it.  It’s pretty bare-bones and it lets you change
the syntax for find to suit your immediate needs.

Generally, though, I find =find-name-dired= to be more useful for day-to-day use
when all I want is to feed it a single string to match against.

By default Emacs will pass =-exec= to =find= and that makes it very slow.  It is
better to collate the matches and then use =xargs= to run the command.
#+END_QUOTE

#+BEGIN_SRC emacs-lisp
(use-package find-dired
  :config
  (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))
#+END_SRC

*** peep-dired
    This is a minor mode that can be enabled from a dired buffer.  Once enabled
    it will show the file from point in the other window.  Moving to the other
    file within the dired buffer with =down=/=up= or =C-n=/=C-p= will display a
    different file.  Hitting =SPC= will scroll the peeped file down, whereas
    =C-SPC= and =backspace= will scroll it up.

    The configuration for this snippet was taken from Howard Abrams' [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#dired-options][emacs.org]]
    and from the github [[https://github.com/asok/peep-dired][README]] of the project on [2019-02-04 Mon].

    #+begin_src emacs-lisp
    (use-package peep-dired
      :ensure t
      :defer t
      :bind (:map dired-mode-map
                  ("P" . peep-dired))
      :config
      (setq peep-dired-cleanup-eagerly t)
      (setq peep-dired-enable-on-directories t)
      (setq peep-dired-ignored-extensions '("mkv" "iso" "mp4")))
    #+end_src

*** dired sort directories first
#+BEGIN_SRC emacs-lisp
;; 03Oct2012
;; http://www.emacswiki.org/emacs/DiredSortDirectoriesFirst
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
    (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort))
#+END_SRC

*** enhanced beginning- and end-of-buffer
    This code snippet is not just specific to dired, but is of most use there.
    Taken from [[https://fuco1.github.io/2017-05-06-Enhanced-beginning--and-end-of-buffer-in-special-mode-buffers-(dired-etc.).html][here]], on [2017-09-28 Thu].

    #+BEGIN_SRC emacs-lisp
    (defmacro my-special-beginning-of-buffer (mode &rest forms)
      "Define a special version of `beginning-of-buffer' in MODE.

    The special function is defined such that the point first moves
    to `point-min' and then FORMS are evaluated.  If the point did
    not change because of the evaluation of FORMS, jump
    unconditionally to `point-min'.  This way repeated invocations
    toggle between real beginning and logical beginning of the
    buffer."
      (declare (indent 1))
      (let ((fname (intern (concat "my-" (symbol-name mode) "-beginning-of-buffer")))
            (mode-map (intern (concat (symbol-name mode) "-mode-map")))
            (mode-hook (intern (concat (symbol-name mode) "-mode-hook"))))
        `(progn
           (defun ,fname ()
             (interactive)
             (let ((p (point)))
               (goto-char (point-min))
               ,@forms
               (when (= p (point))
                 (goto-char (point-min)))))
           (add-hook ',mode-hook
                     (lambda ()
                       (define-key ,mode-map
                         [remap beginning-of-buffer] ',fname))))))

(defmacro my-special-end-of-buffer (mode &rest forms)
  "Define a special version of `end-of-buffer' in MODE.

    The special function is defined such that the point first moves
    to `point-max' and then FORMS are evaluated.  If the point did
    not change because of the evaluation of FORMS, jump
    unconditionally to `point-max'.  This way repeated invocations
    toggle between real end and logical end of the buffer."
  (declare (indent 1))
  (let ((fname (intern (concat "my-" (symbol-name mode) "-end-of-buffer")))
        (mode-map (intern (concat (symbol-name mode) "-mode-map")))
        (mode-hook (intern (concat (symbol-name mode) "-mode-hook"))))
    `(progn
       (defun ,fname ()
         (interactive)
         (let ((p (point)))
           (goto-char (point-max))
           ,@forms
           (when (= p (point))
             (goto-char (point-max)))))
       (add-hook ',mode-hook
                 (lambda ()
                   (define-key ,mode-map
                     [remap end-of-buffer] ',fname))))))

;; Dired
(my-special-beginning-of-buffer dired
  (while (not (ignore-errors (dired-get-filename)))
    (dired-next-line 1)))
(my-special-end-of-buffer dired
  (dired-previous-line 1))

;; Occur
(my-special-beginning-of-buffer occur
  (occur-next 1))
(my-special-end-of-buffer occur
  (occur-prev 1))

;; IBuffer
(my-special-beginning-of-buffer ibuffer
  (ibuffer-forward-line 1))
(my-special-end-of-buffer ibuffer
  (ibuffer-backward-line 1))

;; Recentf
(my-special-beginning-of-buffer recentf-dialog
  (when (re-search-forward "^  \\[" nil t)
    (goto-char (match-beginning 0))))
(my-special-end-of-buffer recentf-dialog
  (re-search-backward "^  \\[" nil t))

;; Org-agenda
(my-special-beginning-of-buffer org-agenda
  (org-agenda-next-item 1))
(my-special-end-of-buffer org-agenda
  (org-agenda-previous-item 1))

;; ag
(my-special-beginning-of-buffer ag
  (compilation-next-error 1))
(my-special-end-of-buffer ag
  (compilation-previous-error 1))
#+END_SRC

** lisp-mode
   Emacs Lisp Mode is one of the best Programming Modes that comes with Emacs
   for working with EmacsLisp.

   #+BEGIN_SRC emacs-lisp
   (use-package lisp-mode
     :config
     (add-hook 'emacs-lisp-mode-hook #'eldoc-mode)
     (add-hook 'emacs-lisp-mode-hook #'rainbow-delimiters-mode)
     (define-key emacs-lisp-mode-map (kbd "C-c C-c") #'eval-defun)
     (define-key emacs-lisp-mode-map (kbd "C-c C-b") #'eval-buffer)
     (add-hook 'lisp-interaction-mode-hook #'eldoc-mode)
     (add-hook 'eval-expression-minibuffer-setup-hook #'eldoc-mode))
   (use-package ielm
     :config
     (add-hook 'ielm-mode-hook #'eldoc-mode)
     (add-hook 'ielm-mode-hook #'rainbow-delimiters-mode))
   #+END_SRC

** whitespace
   From Bozhidar Batsov's [[https://github.com/bbatsov/emacs.d][init.el]].

   #+BEGIN_SRC emacs-lisp
   (use-package whitespace
     :init
     (dolist (hook '(prog-mode-hook text-mode-hook))
       (add-hook hook #'whitespace-mode))
     :config
     (setq whitespace-line-column 80)
     (setq whitespace-style '(face trailing tabs lines-tail newline
                                   empty-line indentation newline-mark)))
   #+END_SRC

* Third Party Packages
** ag
   #+BEGIN_SRC emacs-lisp
   (use-package ag
     :ensure t)
   #+END_SRC

** CANCELLED aggressive-indent
 =electric-indent-mode= is enough to keep your code nicely aligned when all you
 do is type.  However, once you start shifting blocks around, transposing lines,
 or slurping and barfing sexps, indentation is bound to go wrong.

 =aggressive-indent-mode= is a minor mode that keeps your code always indented.
 It reindents after every change, making it more reliable than
 =electric-indent-mode=.

#+BEGIN_SRC emacs-lisp
(use-package aggressive-indent
  :ensure t
  :config
  (global-aggressive-indent-mode 1))
#+END_SRC
** ace-window
   GNU Emacs package for selecting a window to switch to.

   #+BEGIN_SRC emacs-lisp
   (use-package ace-window
     :ensure t
     :after key-chord)
   #+END_SRC

** avy
   =avy= is a GNU Emacs package for jumping to visible text using a char-based
   decision tree.

   #+BEGIN_SRC emacs-lisp
   (use-package avy
     :ensure t
     :after key-chord)
   #+END_SRC

** browse-kill-ring
   #+BEGIN_SRC emacs-lisp
   (use-package browse-kill-ring
     :ensure t
     :defer t
     :after key-chord)
   #+END_SRC

** company
   #+BEGIN_SRC emacs-lisp
   (use-package company
     :ensure t
     :config
     (setq company-show-numbers t)
     (setq company-minimum-prefix-length 3)
     (setq company-tooltip-align-annotations t)
     (setq company-tooltip-flip-when-above t)
     (add-hook 'after-init-hook 'global-company-mode))
   #+END_SRC

** crux
   #+BEGIN_SRC emacs-lisp
   (use-package crux
     :ensure t
     :after key-chord
     :bind (("C-c o"                        . crux-open-with)
            ("M-o"                          . crux-smart-open-line)
            ("C-c n"                        . crux-cleanup-buffer-or-region)
            ("C-c f"                        . crux-recentf-find-file)
          ("C-M-z"                          . crux-indent-defun)
            ("C-c u"                        . crux-view-url)
            ("C-c e"                        . crux-eval-and-replace)
            ("C-c w"                        . crux-swap-windows)
            ("C-c D"                        . crux-delete-file-and-buffer)
            ("C-c r"                        . crux-rename-buffer-and-file)
            ("C-c t"                        . crux-visit-term-buffer)
            ("C-c k"                        . crux-kill-line-backwards)
            ("C-c I"                        . crux-find-user-init-file)
            ("C-c S"                        . crux-find-shell-init-file)
            ("s-r"                          . crux-recentf-find-file)
            ("s-j"                          . crux-top-join-line)
            ("C-^"                          . crux-top-join-line)
            ("s-k"                          . crux-kill-whole-line)
            ("C-<backspace>"                . crux-kill-line-backwards)
            ("s-o"                          . crux-smart-open-line-above)
            ([remap move-beginning-of-line] . crux-move-beginning-of-line)
            ([(shift return)]               . crux-smart-open-line)
            ([(control shift return)]       . crux-smart-open-line-above)
            ([remap kill-whole-line]        . crux-kill-whole-line)
            ("C-c s"                        . crux-ispell-word-then-abbrev))
     :config
     (setq crux-shell "/bin/zsh"))
   #+END_SRC

** discover-my-major
   Discover my major enables the easy finding of the key bindings of the current
   Emacs major mode.  This headline was added on [2019-02-04 Mon].

   #+begin_src emacs-lisp
   (use-package discover-my-major
     :ensure t
     :defer t
     :bind
     ("C-h C-m" . discover-my-major))
   #+end_src

** easy-kill
   [[https://github.com/leoliu/easy-kill][=easy-kill=]] is an awesome package that allows you to save up on the steps
   you’d normally have to take when saving and killing stuff.  It's called
   easy-kill, but could have just as easily been named easy-save or fast-kill.

   #+BEGIN_SRC emacs-lisp
   (use-package easy-kill
     :ensure t
     :config
     (global-set-key [remap kill-ring-save] #'easy-kill)
     (global-set-key [remap mark-sexp] #'easy-mark))
   #+END_SRC

** ess
   #+BEGIN_SRC emacs-lisp
   (use-package ess
     :ensure t
     :defer t
     :init
     (require 'ess-site)
     :config
     (require 'smartparens-ess)
     (add-hook 'inferior-ess-mode-hook 'smartparens-strict-mode)
     (add-hook 'ess-mode-hook 'smartparens-strict-mode)
     (setq orgstruct-heading-prefix-regexp "## ")
     (add-hook 'ess-mode-hook 'turn-on-orgstruct)
     ;; new in ESS 19.04
     (define-key ess-r-mode-map "_" #'ess-insert-assign)
     (define-key inferior-ess-r-mode-map "_" #'ess-insert-assign))
   #+END_SRC

** exec-path-from-shell
   A GNU Emacs library to ensure environment variables inside Emacs look the
   same as in the user's shell.

   #+BEGIN_SRC emacs-lisp
   (use-package exec-path-from-shell
     :ensure t
     :defer t
     :config
     (when (memq window-system '(mac ns))
       (exec-path-from-shell-initialize)))
   #+END_SRC

** expand-region
   #+BEGIN_SRC emacs-lisp
   (use-package expand-region
     :ensure t
     :defer t
     :bind ("C-=" . er/expand-region))
   #+END_SRC

** git-timemachine
   #+BEGIN_SRC emacs-lisp
   (use-package git-timemachine
     :ensure t
     :defer t
     :bind (("s-g" . git-timemachine)))
   #+END_SRC

** imenu-anywhere
   =imenu-anywhere= provides navigation for imenu tags across all buffers that
   satisfy a filtering criteria.  Available criteria are: all buffers with the
   same major mode, same project buffers and user defined list of friendly mode
   buffers.

   #+BEGIN_SRC emacs-lisp
   (use-package imenu-anywhere
     :ensure t
     :defer t
     :bind (("C-c i" . imenu-anywhere)))
   #+END_SRC

** haskell-mode
   This is an Emacs mode for editing, debugging and developing Haskell
   programs. [[http://haskell.github.io/haskell-mode/][Home page]].

   #+BEGIN_SRC emacs-lisp
   (use-package haskell-mode
     :ensure t
     :defer t
     :config
     (add-hook 'haskell-mode #'subword-mode))
   #+END_SRC

** hungry-delete
   From an Artur Malabarba [[http://endlessparentheses.com/hungry-delete-mode.html][post]].
   #+BEGIN_SRC emacs-lisp
   (use-package hungry-delete
     :ensure t
     :config
     (global-hungry-delete-mode))
   #+END_SRC

** key-chord
   Key-chord lets you bind commands to combinations of key-strokes.  Here a “key
   chord” means two keys pressed simultaneously, or a single key quickly pressed
   twice.

   #+BEGIN_SRC emacs-lisp
   (use-package key-chord
     :ensure t
     :config
     (key-chord-define-global "jh" 'avy-goto-word-1)
     (key-chord-define-global "jl" 'avy-goto-line)
     (key-chord-define-global "jk" 'avy-goto-char)
     (key-chord-define-global "JJ" 'crux-switch-to-previous-buffer)
     (key-chord-define-global "uu" 'undo-tree-visualize)
     (key-chord-define-global "ww" 'ace-window)
     (key-chord-define-global "xx" 'execute-extended-command)
     (key-chord-define-global "yy" 'browse-kill-ring)
     (key-chord-mode 1))
   #+END_SRC

** lispy
   #+BEGIN_SRC emacs-lisp
   (use-package lispy
     :ensure t
     :config
     (add-hook 'emacs-lisp-mode-hook (lambda () (lispy-mode 1))))
   #+END_SRC

** magit
   #+BEGIN_SRC emacs-lisp
   (use-package magit
     :ensure t
     :defer t
     :bind (("C-x g" . magit-status)))
   #+END_SRC

** markdown-mode
   =markdown-mode= is a major mode for GNU Emacs which provides syntax
   highlighting and supporting commands for editing Markdown files.  It provides
   keybindings and commands for inserting Markdown elements and to assist in
   calling =markdown= to parse the source code or preview the document in a
   browser.  It also, optionally, provides syntax highlighting for wiki links
   and embedded itex mathematical expressions.

   #+BEGIN_SRC emacs-lisp
   (use-package markdown-mode
     :ensure t
     :defer t
     :mode (("\\.md\\'" . gfm-mode)
            ("\\.markdown\\'" . gfm-mode))
     :config
     (setq markdown-fontify-code-blocks-natively t))
   #+END_SRC

** move-text
   MoveText allows you to move the current line using M-up / M-down (or any
   other bindings you choose) if a region is marked, it will move the region
   instead.

   Using the prefix arg (C-u number or META number) will predetermine how many
   lines to move.

   #+BEGIN_SRC emacs-lisp
   (use-package move-text
     :ensure t
     :defer t
     :bind
     (("M-," . move-text-up))
     (("M-." . move-text-down)))
   #+END_SRC

** page-break-lines
   From Steve Purcell.  Github page [[https://github.com/purcell/page-break-lines][here]].
   #+BEGIN_SRC emacs-lisp
   (use-package page-break-lines
     :ensure t
     :config
     (global-page-break-lines-mode))
   #+END_SRC

** polymode
   Taken from [[https://github.com/basille/.emacs.d/blob/master/init.el][here]], on [2017-01-09 Mon].
   #+BEGIN_SRC emacs-lisp
   ;; Polymode to load several modes (e.g. Markdown + ESS)
   ;; https://github.com/vitoshka/polymode
   (use-package polymode
     :ensure t
     :defer t
     :config
     (use-package poly-R
       :ensure t)
     (use-package poly-markdown
       :ensure t)
     (use-package poly-noweb
       :ensure t)
     (use-package poly-org
       :ensure t)
     :mode
     ("\\.md"       . poly-markdown-mode)   ; Markdown files
     ("\\.[rR]md"   . poly-markdown+r-mode) ; RMarkdown files
     ("\\.[sSrR]nw" . poly-noweb+r-mode))       ; Sweave files
   #+END_SRC

** projectile
   Projectile is a project interaction library for Emacs.  Its goal is to
   provide a nice set of features operating on a project level without
   introducing external dependencies (when feasible).  For instance---finding
   project files has a portable implementation written in pure Emacs Lisp
   without the use of GNU find (but for performance sake an indexing mechanism
   backed by external commands exists as well).

   Projectile tries to be practical---portability is great, but if some external
   tools could speed up some task substantially and the tools are available,
   Projectile will leverage them.

   This library provides easy project management and navigation.  The concept of
   a project is pretty basic---just a folder containing special file.  Currently
   =git=, =mercurial=, =darcs= and =bazaar= repos are considered projects by
   default.  So are =lein=, =maven=, =sbt=, =scons=, =rebar= and =bundler=
   projects.  If you want to mark a folder manually as a project just create an
   empty =.projectile= file in it.

   #+BEGIN_SRC emacs-lisp
   (use-package projectile
     :ensure t
     :defer t
     :init
     (setq projectile-completion-system 'ivy)
     :config
     (setq projectile-cache-file (expand-file-name "projectile.cache" savefile-dir))
     (define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
     (projectile-mode +1))
   #+END_SRC

** rainbow-delimiters
   Colours paired parenthesis.

   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-delimiters
     :ensure t
     :config
     (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
   #+END_SRC

** rainbow-mode
   Colorize color names in buffers.

   #+BEGIN_SRC emacs-lisp
   (use-package rainbow-mode
     :ensure t
     :config
     (add-hook 'prog-mode-hook #'rainbow-mode))
   #+END_SRC

** smartparens
   #+BEGIN_SRC emacs-lisp
   (use-package smartparens
     ;; 17Aug2017
     ;; https://gist.github.com/oantolin/5751fbaa7b8ab4f9570893f2adfe1862
     :ensure t
     :defer t
     :init
     ;; (smartparens-global-mode)
     ;; (smartparens-global-strict-mode)
     :bind
     (:map smartparens-mode-map
           ;; taken from http://gongzhitaao.org/dotemacs/#sec:miscpac
           ("C-<right>"           . nil)
           ("C-<left>"            . nil)
           ("C-)"                 . nil)
           ("C-("                 . nil)
           ("C-}"                 . nil)
           ("C-{"                 . nil)
           ("M-<down>"            . nil)
           ("M-<up>"              . nil)
           ("M-r"                 . nil)
           ("C-S-<backspace>"     . nil)
           ("C-c s f"             . sp-forward-sexp)
           ("C-c s b"             . sp-backward-sexp)
           ("C-c s d"             . sp-down-sexp)
           ("C-c s D"             . sp-backward-down-sexp)
           ("C-c s a"             . sp-beginning-of-sexp)
           ("C-c s e"             . sp-end-of-sexp)
           ("C-c s u"             . sp-up-sexp)
           ("C-c s U"             . sp-backward-up-sexp)
           ("C-c s t"             . sp-transpose-sexp)
           ("C-c s n"             . sp-next-sexp)
           ("C-c s p"             . sp-previous-sexp)
           ("C-c s k"             . sp-kill-sexp)
           ("C-c s w"             . sp-copy-sexp)
           ("C-c s s"             . sp-forward-slurp-sexp)
           ("C-c s r"             . sp-forward-barf-sexp)
           ("C-c s S"             . sp-backward-slurp-sexp)
           ("C-c s R"             . sp-backward-barf-sexp)
           ("C-c s F"             . sp-forward-symbol)
           ("C-c s B"             . sp-backward-symbol)
           ("C-c s ["             . sp-select-previous-thing)
           ("C-c s ]"             . sp-select-next-thing)
           ("C-c s C-i"           . sp-splice-sexp)
           ("C-c s <delete>"      . sp-splice-sexp-killing-forward)
           ("C-c s <backspace>"   . sp-splice-sexp-killing-backward)
           ("C-c s C-<backspace>" . sp-splice-sexp-killing-around)
           ("C-c s C-w"           . sp-wrap)
           ("C-c s C-u"           . sp-unwrap-sexp)
           ("C-c s C-b"           . sp-backward-unwrap-sexp)
           ("C-c s C-t"           . sp-prefix-tag-object)
           ("C-c s C-p"           . sp-prefix-pair-object)
           ("C-c s C-c"           . sp-convolute-sexp)
           ("C-c s C-a"           . sp-absorb-sexp)
           ("C-c s C-e"           . sp-emit-sexp)
           ("C-c s C-p"           . sp-add-to-previous-sexp)
           ("C-c s C-n"           . sp-add-to-next-sexp)
           ("C-c s C-j"           . sp-join-sexp)
           ("C-c s C-s"           . sp-split-sexp)
           ("C-c s C-r"           . sp-raise-sexp))
     :config
     (add-hook 'eval-expression-minibuffer-setup-hook #'smartparens-mode))
   #+END_SRC

** swiper
*** counsel
    #+BEGIN_SRC emacs-lisp
    (use-package counsel
      :ensure t
      :bind (("M-x"           . counsel-M-x)
             ("C-x C-f"       . counsel-find-file)
             ("C-h v"         . counsel-describe-variable)
             ("C-h f"         . counsel-describe-function))
      :config
      (use-package flx
        :ensure t)
      ;; mix fuzzy with plus (.* for each space)
      ;; http://oremacs.com/2016/01/06/ivy-flx/
      (setq ivy-re-builders-alist
            '((ivy-switch-buffer . ivy--regex-plus)
              (swiper            . ivy--regex-plus)
              (swiper-all	 . regexp-quote)
              (t		 . ivy--regex-fuzzy)))
      (setq ivy-initial-inputs-alist nil))
    #+END_SRC

*** ivy
    #+BEGIN_SRC emacs-lisp
    (use-package ivy
      :ensure t
      :bind (("C-x b" . ivy-switch-buffer))
      :config
      (ivy-mode 1)
      (setq ivy-use-virtual-buffers t)
      (setq ivy-display-style 'fancy)
      (progn
        (global-set-key (kbd "C-c C-r") 'ivy-resume)))
    #+END_SRC

*** swiper
    #+BEGIN_SRC emacs-lisp
    (use-package swiper
      :ensure t
      :bind (("C-s" . swiper)
             ("C-c q" . swiper-all)))
    #+END_SRC

*** hydra
    #+BEGIN_SRC emacs-lisp
    (use-package hydra
      :ensure t
      :defer t)
    #+END_SRC

** undo-tree
   #+BEGIN_SRC emacs-lisp
   (use-package undo-tree
     :ensure t
     :after key-chord
     :config
     ;; autosave the undo-tree history
     (setq undo-tree-history-directory-alist
           `((".*" . ,temporary-file-directory)))
     (setq undo-tree-auto-save-history t))
   #+END_SRC

** volatile-highlights
   #+BEGIN_SRC emacs-lisp
   (use-package volatile-highlights
     :ensure t
     :defer t
     :config
     (volatile-highlights-mode +1))
   #+END_SRC

** which-key
   #+BEGIN_SRC emacs-lisp
   (use-package which-key
     :ensure t
     :defer t
     :config
     (which-key-mode 1))
   #+END_SRC

** wrap-region
   Wrap region is a minor mode for Emacs that wraps a region with punctuations.
   For "tagged" markup modes, such as HTML and XML, it wraps with tags.  This
   configuration is taken from Howard Abrams [[https://github.com/howardabrams/dot-files/blob/master/emacs.org#block-wrappers][emacs.org]] file on [2019-02-04 Mon].

   #+begin_src emacs-lisp
   (use-package wrap-region
     :ensure t
     :config
     (wrap-region-global-mode t)
     (wrap-region-add-wrappers
      '(("(" ")")
        ("[" "]")
        ("{" "}")
        ("<" ">")
        ("'" "'")
        ("\"" "\"")
        ("‘" "’" "q")
        ("“" "”" "Q")
        ("*" "*" "b" org-mode)                   ; bolden
        ("*" "*" "*" org-mode)                   ; bolden
        ("/" "/" "i" org-mode)                   ; italics
        ("/" "/" "/" org-mode)                   ; italics
        ("~" "~" "c" org-mode)                   ; code
        ("~" "~" "~" org-mode)                   ; code
        ("=" "=" "v" org-mode)                   ; verbatim
        ("=" "=" "=" org-mode)                   ; verbatim
        ("_" "_" "u" '(org-mode markdown-mode))  ; underline
        ("**" "**" "b" markdown-mode)            ; bolden
        ("*" "*" "i" markdown-mode)              ; italics
        ("`" "`" "c" '(markdown-mode ruby-mode)) ; code
        ("`" "'" "c" lisp-mode)                  ; code
        )))
   #+end_src

** worg
   GNU Emacs minor mode that provides vi-like bindings for org-mode.

   #+BEGIN_SRC emacs-lisp
   (use-package worf
     :ensure t
     :defer t)
   #+END_SRC

** zop-top-char
   A visual zap-to-char command for Emacs.

   #+BEGIN_SRC emacs-lisp
   (use-package zop-to-char
     :ensure t
     :defer t
     :bind (("M-z" . zop-up-to-char)
            ("M-Z" . zop-to-char)))
   #+END_SRC
* Eshell
  This Mike Petersen's [[https://www.masteringemacs.org/article/complete-guide-mastering-eshell][article]] on Eshell on his Mastering Emacs blog is a must
  read.  Also, see this [[http://howardism.org/Technical/Emacs/eshell-present.html][blogpost]] from Howard Abrams outlining some of Eshell
  strengths.

  This snippet dispatches programs to 'ansi-term' automatically:

#+BEGIN_SRC emacs-lisp
  ;; (add-to-list 'eshell-visual-commands "htop")
#+END_SRC

This snippet defines eshell aliases:

#+BEGIN_SRC emacs-lisp
  (defalias 'ff 'find-file)
  (defalias 'd 'dired)
#+END_SRC

This snippet configures the prompt:

#+BEGIN_SRC emacs-lisp
  (setq eshell-prompt-function
        (lambda ()
          (concat
           (propertize "┌─[" 'face `(:foreground "grey50"))
           (propertize (user-login-name) 'face `(:foreground "#5272AF"))
           (propertize "@" 'face `(:foreground "grey50"))
           (propertize (system-name) 'face `(:foreground "#2257A0"))
           (propertize "]──[" 'face `(:foreground "grey50"))
           (propertize (format-time-string "%H:%M" (current-time)) 'face `(:foreground "#a9a1e1"))
           (propertize "]──[" 'face `(:foreground "grey50"))
           (propertize (concat (eshell/pwd)) 'face `(:foreground "#842879"))
           (propertize "]\n" 'face `(:foreground "grey50"))
           (propertize "└─>" 'face `(:foreground "grey50"))
           (propertize (if (= (user-uid) 0) " # " " $ ")))))
#+END_SRC

